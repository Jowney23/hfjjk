
#### [<1.0.2>]

|     发布日期         | 2022/08/1 |
| -------------- | -------- |
|     版本         | 1.0.0 |
|     说明         | 媒体中心接口说明及相应文档发布 |
|     发布部门         | 极氪软件系统研发 |

|     发布日期         | 2022/10/11 |
| -------------- | -------- |
|     版本         | 1.0.1 |
|     说明         |控制端新增音乐类型id及文字说明        |
|     发布部门         | 极氪软件系统研发 |

|     发布日期         | 2022/11/22 |
| -------------- | -------- |
|     版本         | 1.0.2 |
|     说明         | 蓝牙双音源接口定义发布         |
|     发布部门         | 极氪软件系统研发 |

[<1.0.2>]: <version-diff-url>
##    媒体中心对接指引

###  媒体接入能力提供

##### 什么是媒体中心?
MediaCenterAPI SDK是媒体中心与App之间交互的桥梁，提供了接收媒体播放信息的方法和媒体播放控制的方法， 为调用者提供多媒体节目播放信息显示能力，以及节目播放控制能力。




##### 哪些应用需要接入媒体中心？

音乐类，视频类软件。


##### 如何申请媒体中心权限？



##### 媒体中心初始化说明
```java
/**
 * 媒体中心SDK初始化
 * MediaCenterAPI.get().init()
 * SDK提供的所有方法，需要在初始化成功以后才能使用，初始化的样例代码如下。
 */
MediaCenterAPI.get().init(this, new ApiReadyCallback() {
	@Override
	public void onAPIReady(boolean isReady, String message) {
		if (isReady) {

		}
	}
});
```

####  播控能力接入

用户可通过媒体中心的接入，实现播控能力的接入。

##### 播控指令清单

|                | 播放 | 暂停 | 上一曲 | 下一曲 | 收藏 | 下载 | 快进 | 快退 | 模式切换 | 歌曲选择 | 音源切换 | 重新播放 | 打开关闭 | 进度跳转 | 分类歌单 | 播放收藏 |
| -------------- | ---- | ---- | ------ | ------ | ---- | ---- | ---- | ---- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| **VR播放指令** | √    | √    | √      | √      | √    | √    |      |      | √        |          | √        |          | √        | √        | √        | √        |
| **方控指令**   | √    | √    | √      | √      | √    | √    | √    | √    |          |          | √        |          |          |          |          |          |
| **DIM控制**    | √    | √    |        |        |      |      |      |      |          |          | √        |          |          |          |          |          |
| **Docker**     | √    | √    | √      | √      | √    |      |      |      |          |          |          |          | √        |          |          |          |
| ~~**Widget**~~ | √    | √    | √      | √      | √    |      |      |      |          | √        |          |          | √        |          |          |          |
| **后排屏**     | √    | √    | √      | √      | √    |      |      |      |          |          | √        |          |          |          |          |          |
| **场景引擎**   |      |      |        |        |      |      |      |      |          |          |          |          |          |          | √        |          |



自定义类实现MusicClient接口
该接口作为接收媒体中心回调的入口（包括方控、Widget、仪表控制、VR等），客户端无需关注实现细节，所有相关控制统一接口输出

```java

// 注册获取媒体中心可识别的token，其他接口需带上该token才能正常使用，否则产生Illegalargumentexception
private MusicClient mMusicClient=new CustomMusicClient();
Object token = MediaCenterAPI.get().registerMusic("包名", mMusicClient);
public class CustomMusicClient extends  MusicClient {
	public CustomMusicClient () {
	}

	/**
	 * 控制播放
	 * @return 成功返回true，失败返回false
	 */
	public boolean onPlay() {
		return false;
	}

	/**
	 * 控制暂停
	 * @return 成功返回true，失败返回false
	 */
	public boolean onPause() {

		return false;
	}

	/**
	 * 控制下一曲播放
	 * @return 成功返回true，失败返回false
	 */  
	public boolean onNext() {

		return false;
	}

	/**
	 * 控制上一曲播放
	 * @return 成功返回true，失败返回false
	 */   
	public boolean onPrevious() {

		return false;
	}

	/**
	 * 控制快进
	 * @return 成功返回true，失败返回false
	 */     
	public boolean onForward() {

		return false;
	}

	/**
	 * 控制快退
	 * @return 成功返回true，失败返回false
	 */
	public boolean onRewind() {

		return false;
	}

	/**
	 * 切换播放类型
     * @param i
     * 播放模式-全部循环 LOOP_MODE_ALL = 0;
     * 播放模式-单曲循环 LOOP_MODE_SINGLE = 1;
     * 播放模式-随机播放 LOOP_MODE_SHUFFLE = 2;
     *  LOOP_MODE_NEXT_MODE = 3;
     * @return 成功返回true，失败返回false
     */
    public boolean onLoopModeChange(int i) {
        return false;
    }

	/**
	 * 切换音源
	 * @param sourceType 音源类型
	 * @param preApp 上一个播放应用
	 * @return 成功返回true，失败返回false
	 */
    public boolean onSourceChanged(int sourceType, String preApp) {
        Log.d(CLASSNAME, " onSourceSelected: " + sourceType);
        return false;
    }

 /**
     * 选择歌单中的音乐播放
     *
     * @param mediaListType 歌单类型  {@link AbstractMusicClient.MediaListType}
     * @param sourceType    音源类型  {@link com.ecarx.eas.sdk.mediacenter.SourceType}
     * @param uuid          歌曲id
     * @return true 执行成功, false 执行失败
     */
    public boolean selectListMediaPlay(int mediaListType, int sourceType, String uuid){
         //todo
        return false;    
    }

    /**
     *
     * 按收藏类型对当前节目收藏，语音下发收藏指令
     * 完成操作后，执行结果反馈{@link IMediaCenterAPI.updateCollectMsg}
     * @param type      收藏类型 {@link AbstractMusicClient.CollectionType}
     * @param isCollect 是否收藏
     * @return true 收藏成功, false 收藏失败
     * @since
     */
    @Deprecated
    public boolean onCollect(@CollectionType int type, boolean isCollect){
         //todo
        return false;    
    }  

}
```



注册获取Token

```java
// 注册获取媒体中心可识别的token，其他接口需带上该token才能正常使用，否则产生Illegalargumentexception
private MusicClient mMusicClient=new CustomMusicClient();
Object token = MediaCenterAPI.get().registerMusic("包名", mMusicClient);
```

重要的方法requestPlay

// 当媒体播放时，需要申请媒体中心控制焦点，只有获取到媒体中心控制焦点才能获取信息更新权与受控制权。
// 注意：当三方应用获得车机端音频长焦点时 需调用requestPlay方法申请媒体中心使用焦点（请求的是媒体中心使用焦点）。

```
MediaCenterAPI.get().requestPlay(token);
```

```
MediaCenterAPI.get().requestPlay(token,audioType);//audioType 0x0000:default Audio  0x0001:Bluetooth headset
```



#### 媒体信息透出

|                | 播放状态 | 歌曲信息 | 歌单信息 | 收藏展示 | 下载展示 | 播放模式 | 收藏列表 |
| -------------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| **仪表盘**     | √        | √        |          | √        |          |          |          |
| **Docker**     | √        | √        |          | √        |          |          |          |
| ~~**Widget**~~ | √        | √        | √        |          | √        |          |          |
| **HUD**        | √        | √        |          | √        |          |          |          |
| **后排屏**     | √        | √        | √        | √        |          | √        | √        |


车与人交互，车载系统中模块之间的交互都是建立在数据互通基础之上，媒体中心是桥梁，而数据是信息的载体，车载多媒体通过CommonAPI把数据传到媒体中心，媒体中心综合数据并把数据传到Widget，仪表上显示，以及告知语音端媒体的播放信息。无论是仪表，Widget，方控，VR都需要当前正在播放的媒体信息以方便随时能根据播放状态发出正确的控制指令到媒体中心。如果没有数据载体，只有“桥梁”，媒体中心中所接入的服务将无用武之地。因此正确的更新多媒体节目信息到媒体中心是至关重要的。

音源类型介绍
音源类型参数在  zeekr-sdk-mediacenter-x.x.x.jar包中`SourceType.java`中，媒体中心所支持的音源都是基于这些类型，详细简介如下表:

|       常量         | 描述 |
| -------------- | -------- |
| SOURCE_TYPE_LOCAL     | 本地音乐         |
| SOURCE_TYPE_USB     | USB1音乐         |
| SOURCE_TYPE_BT     | 蓝牙音乐         |
| SOURCE_TYPE_FM     | 收音机FM         |
| SOURCE_TYPE_AM     | 收音机AM         |
| SOURCE_TYPE_ONLINE     | 在线网络音乐         |
| SOURCE_TYPE_USB2     | USB2音乐         |
| SOURCE_TYPE_STATION     | 主播电台         |
| SOURCE_TYPE_NET_NEWS     | 网络新闻         |
| SOURCE_TYPE_NET_VIDEO     | 网络视频         |
| SOURCE_TYPE_PODCASTS     | 播客         |

`AbstractMusicClient.java` 中所有涉及到的常量介绍如下表
|       常量          | 描述 |
| -------------- | -------- |
| LOOP_MODE_ALL     | 顺序播放         |
| LOOP_MODE_SINGLE     | 单曲循环         |
| LOOP_MODE_SHUFFLE     | 随机播放         |
| TYPE_COLLECTION_MUSIC     | 收藏音乐         |
| TYPE_COLLECTION_VIDEO     | 收藏视频         |
| TYPE_COLLECTION_RADIO     | 收藏电台         |
| TYPE_COLLECTION_NEWS     | 收藏新闻         |
| TYPE_DOWNLOAD_MUSIC     | 下载音乐         |
| TYPE_DOWNLOAD_VIDEO     | 下载视频         |
| TYPE_DOWNLOAD_NEWS     | 下载新闻         |
| TYPE_MEDIA_LIST_NORMAL     | 正常的列表类型         |

`MusicPlaybackInfo.java` 中getPlaybackStatus返回的当前状态所有涉及到的常量介绍如下表
|       常量          | 描述 |
| -------------- | -------- |
| STATE_PAUSED     		| 暂停播放         |
| STATE_PLAYING     	| 播放中         |
| STATE_INTERRUPT     	| 停止播放         |
| STATE_NONE     		| 无内容可播放         |
| STATE_FAST_FORWARDING     | 快进中         |
| STATE_REWINDING     	| 快退中         |
| STATE_BUFFERING     	| 缓冲中         |
| STATE_ERROR     		| 出错         |
| STATE_SKIPPING_TO_PREVIOUS     | 切换到上一首中         |
| STATE_SKIPPING_TO_NEXT     	| 切换到下一首中         |
| STATE_VIDEO_BACKGROUND_PAUSE     | 视频应用退到后台（停止播放）         |
| STATE_VIDEO_BACKGROUND_PLAY     	| 视频应用后台播放中（音频类）         |
| STATE_VIDEO_DLNA_PLAY     		| 投屏中         |
| STATE_VIDEO_DLNA_STOP     				| 投屏已断开         |

更新正在播放的多媒体节目信息，使其显示到仪表，Widget，并更新到VR和方控。
正常更新数据的策略是，只要SourceType改变即需第一步更新同步，而后再更新当前多媒体的播放节目信息。只要多媒体节目的任何状态信息发生改变，信息就须更新到媒体中心。
更新数据方法如下:

```java
 // 更新当前播放的音源
 MediaCenterAPI.get().updateCurrentSourceType(token,sourceType);
 // 更新当前播放的音源信息
 // PS：目前的版本暂时不支持匿名内部类的方式调用，请使用类似下面成员变量的方式进行调用，后续版本可能会考虑兼容。
private MusicPlaybackInfo mMusicPlaybackInfo=new MyMusicPlaybackInfo(); 
MediaCenterAPI.get().updateMusicPlaybackState(token,mMusicPlaybackInfo);
  //更新音乐类客户端当前播放进度
MediaCenterAPI.get().updateCurrentProgress( token,progress);
  //更新音乐类客户端当前音源的播放列表
MediaCenterAPI.get().updateCurrentPlaylist(token,sourceType, List<MediaInfo> playlist);

//其中 updateMusicPlaybackState(token,mMusicPlaybackInfo)的信息实体mMusicPlaybackInfo类实现参考如下：
public final static class MyMusicPlaybackInfo extends MusicPlaybackInfo{
 @Override
	public int getSourceType() {
	return 0;
  }
  /*** 如果音频焦点长时间失去，
	需要更新MusicPlaybackInfo#getPlaybackStatus状态为	           PLAYBACK_STATUS_PAUSED(0)，	 
	* 如果音频焦点短暂失去，
	需要更新MusicPlaybackInfo
	#getPlaybackStatus状态PLAYBACK_STATUS_INTERRUPT(2)，
	*/
 @Override
public int getPlaybackStatus() {
	return source;
}
/**
 * 当前播放节目所在的节目列表ID
* @return 节目列表ID 节目列表类型  {@link MusicClient.MediaListType}
* @since  
*/
@Override
public String getPlayingMediaListId() {
	return null;
}

/**
 * 用户VIP
 * @return VIP -1 未登录 0 普通用户 大于0 VIP
 * @since {@link }
 */
@Override
public int getVip() {
     return -1;
}
/**
 *  当前播放节目所在节目列表类型
 *   {@link MusicClient.MediaListType}
 * @return 节目列表类型
 */
@Override
public int getPlayingMediaListType() {
      return 0;
}

/**
 * 获取用于唤起App内部播放器页面的 PendingIntent
 * @return PendingIntent
 * @since {@link }
 */
@Override
public PendingIntent getPlayerIntent() {
	return null;
 }
}
特殊情况下，如USB 拔出、蓝牙断开、网络连接断开，客户端需更新MusicPlaybackInfo中的getSourceType()为-1，这样Widget，仪表更新数据并回到初始状态， 并且调用如下API：
// 某个音源媒体加载或者连接失败状态时返回错误信息,errorMsg:例如蓝牙已断开
MediaCenterAPI.get().updateErrorMsg(token,sourceType,errorMsg);
```



更新多媒体节目列表数据，使其显示在Dock，仪表上。如果多媒体节目存在列表，且有需要把相关信息显示到Dock或仪表上，则按照以下方式接入实现

```java
// 音源列表，如果无需仪表显示控制，则无需更新，token 是 register返回的token，SourceTypes是音源列表
MediaCenterAPI.get().updateMediaSourceTypeList(token, sourceTypes);

// 更新媒体播放列表，token 是 register返回的token，MediaListInfo 是列表信息类，其中的列表类型请设置为TYPE_MEDIA_LIST_NORMA,否则无法将当前节目列表刷新到仪表
private MediaListInfoNew mediaListInfo = new MediaListInfoNew();
MediaCenterAPI.get().updateMediaList(token,mediaListInfo);
private class MediaListInfoNew  extends MediaListInfo{
		@Override
		public String getTitle() {
			return null;
		}
		@Override
		public String getMediaListId() {
			return null;
		}
		@Override
		public Uri getArtwork() {
			return null;
		}
		@Override
		public int getSourceType() {
			return -1;
		}
		@Override
		@SuppressLint({"WrongConstant"})
		public int getMediaListType() {
			return -1;
		}
		@Override
		public List<MediaInfo> getMediaList() {
			return null;
		}
		@Override
		public PendingIntent getPendingIntent() {
			return null;
		}
	};


MediaListInfo重要接口getMediaList() item关键内容介绍
使用getUuid()获取节目的唯一id
使用getTitle()获取节目的标题
使用getPlayingItemPositionInQueue()获取节目在列表中的位置
使用getSourceType()获取节目的音源类型
使用getArtwork()获取节目的封面
使用getVip()获取节目vip显示
```
更新多媒体所支持的内容分类列表

```java
// 更新多媒体所支持的内容分类列表, token为注册时返回的token，mediaContentTypes为内容分类列表，内容分类可以参照上面的内容分类列表
List<IMediaContentType> mediaContentTypes = new ArrayList<>();
IMediaContentType mediaContentType=new IMediaContentType();
		 mediaContentType.setId("96");
		 mediaContentType.setName("甜蜜");
mediaContentTypes.add(mediaContentType);
MediaCenterAPI.get().updateMediaContentTypeList(token,mediaContentTypes;

IMediaContentType 信息关键参数：
使用getId()获取内容分类ID
使用getName()获取内容分类标题名称
```
Dock 和 Widget支持三方应用名名称 Icon透出(相应API：`MusicPlaybackInfo#getAppIcon`, `MusicPlaybackInfo#getPackageName`)

目前支持两种方式透出三方icon：
方式一：传三方App内部的icon，此方式必须通过`MusicPlaybackInfo#getPackageName()`传包名，
`MusicPlaybackInfo#getAppIcon` 为以drawable:
//开头， 后面添加drawable类型icon在App内部名称 例：icon在App内部为`R.drawable.launcher`传递的getAppIcon的String为 drawable://launcher，且getPackageName不为空，传递App正确包名
方式二：网络URL http://，https:// SD卡存储路径 content://，file://



#### VR点播能力透出（管道化）

##### 音乐点播类：

|                          | 示例                         | TTS反馈说明                                                  |
| ------------------------ | ---------------------------- | ------------------------------------------------------------ |
| **歌手点播**             | 我想听张学友的歌             | 我想听张学友的歌：      搜索成功：      好的，为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲需要单独付费：      这首歌曲需单独付费，来听听免费的歌曲吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲无车载版权：      这首歌曲暂无车载端版权，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜不到这首歌曲：      资源库里还没有该歌曲，听听其他音乐吧为你播放#歌手名#的#歌曲名#。 |
| **点播歌手的歌曲**       | 我想听张学友的吻别           | 我想听张学友的歌：      搜索成功：      好的，为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲需要单独付费：      这首歌曲需单独付费，来听听免费的歌曲吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲无车载版权：      这首歌曲暂无车载端版权，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜不到这首歌曲：      资源库里还没有该歌曲，听听其他音乐吧为你播放#歌手名#的#歌曲名#。 |
| **歌曲点播**             | 播放小苹果                   | 搜索成功：     好的，为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲需要单独付费：     这首歌曲需单独付费，来听听免费的歌曲吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲无车载版权：     这首歌曲暂无车载端版权，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜不到这首歌曲：     资源库里还没有该歌曲，听听其他音乐吧为你播放#歌手名#的#歌曲名#。 |
| **点播某专辑**           | 我要听大海这张专辑           | 搜索成功：    好的，为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲需要单独付费：    这首歌曲需单独付费，来听听免费的歌曲吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲无车载版权：    这首歌曲暂无车载端版权，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜不到这首歌曲：    资源库里还没有该歌曲，听听其他音乐吧为你播放#歌手名#的#歌曲名#。 |
| **点播歌手的指定专辑**   | 给我搜一下周杰伦的专辑叶惠美 | 搜索成功：   好的，为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲需要单独付费：   这首歌曲需单独付费，来听听免费的歌曲吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲无车载版权：   这首歌曲暂无车载端版权，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜不到这首歌曲：   资源库里还没有该歌曲，听听其他音乐吧为你播放#歌手名#的#歌曲名#。 |
| **按照风格类型点播播放** | 播放摇滚类型歌曲             | 搜索成功：  好的，一起来听#分类#的歌曲吧！<br/>搜到的歌曲需要单独付费：  这首歌曲需单独付费，来听听免费的歌曲吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲无车载版权：  这首歌曲暂无车载端版权，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜不到这个分类：  资源库里还没有该类歌曲，听听其他音乐吧为你播放#歌手名#的#歌曲名#。 |
| **按照排行榜点歌**       | 播放热歌榜                   | 搜索成功： 好的，一起来听#排行榜#的歌曲吧！<br/>搜到的歌曲需要单独付费： 这首歌曲需单独付费，来听听免费的歌曲吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲无车载版权： 这首歌曲暂无车载端版权，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜到的歌曲因非法区域版权原因阻断： 这首歌曲无法在当前国家或地区播放，来听听其他音乐吧!为你播放#歌手名#的#歌曲名#。<br/>搜不到这个排行榜： 资源库里还没有该类歌曲，听听其他音乐吧为你播放#歌手名#的#歌曲名#。 |


声明VR管道化能力

语音管道化目的是为了能让其他客户端App能够使用语音的能力，而设计的一个方案。 语音管道化是语音云端与定制App之间的一条通道，可以解决定制App与语音云端之间的数据交互问题。 语音管道化目前支持将相关语音转化成语义，此处由媒体中心转发给相应的三方多媒体
```java
 VrChannelInfo vrChannelInfo = new VrChannelInfo("第三方包名", "第三版本号 1.0.0",  "description", VrChannelDataType.XIAOKA_VR_CHANNEL);
    /**
     * 处理语音管道中下发的多媒体相关的语义
     * @param domainId 多媒体对应的语音管道的domainId
     * @param semantic 接收到的语义对象
     */
public class VrChannelDataListenerNew extends VrChannelDataListener{
@Override
public void handleVrChannelData(int domainId, SemanticData var2) {
			Log.d(tag,"handleVrChannelData");
	}
}
vrChannelDataListener = new VrChannelDataListenerNew();
SemanticData semanticData = new SemanticData();
SemanticsType 定义了可以实现的功能清单
int[] m = new int[]{SemanticsType.CONTROL_PLAY, SemanticsType.CONTROL_DOWNLOAD, SemanticsType.CONTROL_PAUSE};
try {
	  boolean b = MediaCenterAPI.get().declareVrSemanticsCapability(token, vrChannelInfo, m, vrChannelDataListener);
	  Log.d(tag, "declareVrSemanticsCapability" + b);
} catch (MediaCenterException e) {
		  e.printStackTrace();
	}
}
```
 取消VR管道化能力
 ```java
VrChannelInfo vrChannelInfo = new VrChannelInfo("第三方包名", "1.0.0", "description", VrChannelDataType.XIAOKA_VR_CHANNEL);
				vrChannelDataListener = new VrChannelDataListener();
				SemanticData semanticData = new SemanticData();
				vrChannelDataListener.handleVrChannelData(1, semanticData);
int[] m = new int[]{SemanticsType.CONTROL_PLAY, SemanticsType.CONTROL_DOWNLOAD, SemanticsType.CONTROL_PAUSE};
			try {
					boolean b = MediaCenterAPI.get().cancelVrSemanticsCapability(token, vrChannelInfo);
					Log.d(tag, "declareVrSemanticsCapability" + b);
			} catch (MediaCenterException e) {
					e.printStackTrace();
  }
 ```
VR发送语音需要播放的tts文本信息
```java
VrTtsResultListener vrTtsResultListener =new VrTtsResultListener();
				try {
					boolean b = MediaCenterAPI.get().sendVrTtsActionResult(token,"1","msg",vrTtsResultListener);
					Log.d(tag, "declareVrSemanticsCapability" + b);
				} catch (MediaCenterException e) {
					e.printStackTrace();
			}
```
 注册管道化能力后,当VR模块触发有关媒体播放，查询等请求时，三方应用会收到媒体中心的反馈，应用根据收到的反馈信息完成对客户需求的回应。
```java
//反馈给三方的对象 SemanticData 有如下字段
	/**
	 * 语义值
	 *
	 */
	private int semantic;
	/**
	 * 媒体音源类型
	 */
	private String mediaSource ;
	/**
	 *
	 */
	private String mediaType ;
	/**
	 * 歌曲名
	 */
	private String titleName ;
	/**
	 * 歌手名
	 */
	private String artistName ;
	/**
	 * 专辑名
	 */
	private String albumName ;
	/**
	 * 播放类型
	 */
	private String typeName ;
	/**
	 * 控制类型
	 */
	private String mediaCtrl ;
	/**
	 * 收音机频道
	 */
	private String tunerFrequency ;
	/**
	 * 设置子分类名
     * @param  subTypeName 子分类名
	 */
	private String subTypeName ;
	/**
	 * 模式切换类型  
	 *
	 */
	private int modeType = -1;
	/**
	 * 原始语音文本信息
	 */
	private String originInfo;
	/**
	 * 错误码
	 */
	private String errorCode;
	/**
	 * 错误信息
	 */
	private String errorMsg;

```

##### 播客点播

|                              | 示例                           | TTS反馈                                                      |
| ---------------------------- | ------------------------------ | ------------------------------------------------------------ |
| **按节目名点播**             | 请播道德经                     | 搜索成功： 好的,为你播放#节目名#。<br/>搜索失败： 暂时无法播放，来听听为你播放推荐节目 |
| **按表演者人名点播**         | 我要听郭德纲                   | 搜索成功：好的,为你播放#表演人名##节目名#。<br/>搜索失败：好的,为你播放#表演人名##节目名#。 |
| **按具体表演者的作品名搜索** | 我想听郭德纲的郭德纲最新相声集 | 搜索成功：好的,为你播放#表演人名##节目名#。<br/>搜索失败：好的,为你播放#表演人名##节目名#。 |
| **按节目类别点播**           | 播放相声                       | 搜索成功：好的,为你播放#表演人名##节目名#。<br/>搜索失败：好的,为你播放#表演人名##节目名#。 |



##### 新闻点播

|              | 示例           | TTS反馈                                                      |
| ------------ | -------------- | ------------------------------------------------------------ |
| **分类新闻** | 我要听财经新闻 | 执行成功：  好的，为你播放#分类#新闻。<br/>执行失败：  暂时没有找到相关新闻，为您播放其他内容。 |



##### 视频点播

|              | 示例         | TTS反馈                                                      |
| ------------ | ------------ | ------------------------------------------------------------ |
| **播放视频** | 播放父母爱情 | 搜索成功： 好的,为你播放#节目名#。<br/>搜索失败： 暂时无法播放，来听听为你播放推荐节目 |



#### 行车娱乐限制

行车娱乐用于通知视频类或游戏类应用在某些特定场景下的功能限制



```java
注册行车娱乐限制回调
private DriverRestrictionsCallback iDriverRestrictionCallBack = new  DriverRestrictionsCallback() {
		@Override
		public void onCallback(boolean b) {

			Log.d(tag, "iDriverRestrictionCallBack" + b);

		}
	};
注册回调
MediaCenterAPI.get().initDrivingRestrictions(ClientType.VIDEO,iDriverRestrictionCallBack)
```
返回值 true 表示当前没有限制 false 表示当前有限制



#### 状态恢复
状态恢复保持，媒体中心会保存车机关机前播放的媒体列表和正在播放的媒体信息，在下次开机的时候恢复这些数据并提供给三方多媒体App，并在Dock和仪表显示，目前支持三方App注册状态保持能力，和注销状态保持能力
```java
Intent intent = new Intent("android.intent.acton.send.mediacenter");
				intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
				intent.putExtras(bundle);
				boolean b = false;
				try {
					b = MediaCenterAPI.get().registerMusicRecoveryIntent(token, RecoveryIntentType.INTENT_TYPE_SERVICE,intent);
				} catch (MediaCenterException e) {
					e.printStackTrace();
				}
				LogHelper.e(tag, "注册恢复" + b);

//在该intent的入口，可执行以下操作,抢占控制焦点，确保状态保持恢复数据后，三方App能够正常被媒体中心控制
MediaCenterAPI.get().requestPlay(token);

// 同步获取关机前播放的媒体列表
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
MediaCenterAPI.get().getRecoveryMediaList(token);

// 同步获取关机前播放的媒体信息
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
MediaCenterAPI.get().getRecoveryMusicPlaybackInfo(token);

// 异步获取关机前播放的媒体列表和媒体信息
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
MediaCenterAPI.get().setMusicRecoveryCallback(StateRecoverActivity.mToken, new IMusicRecoveryCallback() {
				@Override
				public void onGetMediaList(MediaListInfo mediaListInfo) {

				}

				@Override
				public void onGetMusicPlaybackInfo(MusicPlaybackInfo musicPlaybackInfo) {

				}
});

// 当三方App获取到恢复的多媒体列表和多媒体信息并处理完这些数据的业务逻辑之后，调用以下API通知媒体中心已经处理完毕，此时媒体中心才会将数据通知Widget、仪表显示
// 因为只有在三方多媒体App处理完恢复数据的业务之后，语音、Widget、仪表、方控按键才能准确控制多媒体相关行为。
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
MediaCenterAPI.get().onMusicRecoveryComplete(token);

// 注销状态保持能力
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
MediaCenterAPI.get().unRegisterMusicRecoveryIntent(token);
```


#### 半屏Widget

##### 半屏模块：

半屏接入流程(三方应用)

半屏应用（0世界）由极氪自研，三方应用通过媒体中心接口，将页面数据透传给半屏。（半屏的tab页标签及 tab页具体信息由三方提供）。

1.为满足半屏 歌曲（歌单）播放 ，进度条拖动以及tab刷新功能，于MusicClient音乐客户端对象中新增以下方法。
```java
  /**
     * 根据tabId  用于接受半屏应用的数据刷新请求
     * @param tabId   半屏tabId
     * @since MediaCenter 1.0.0
     */
  public abstract void getMediaPartTabInfo(int tabId);
    /**
     * 进度条拖动
     * @return true 执行成功, false 执行失败
     * @since MediaCenter 1.0.0
     */
  public abstract boolean progressDrag(long progress );
	/**
		* 半屏播放
		* @since MediaCenter 1.0.0
		* @return true 执行成功, false 执行失败
		*/
 public abstract boolean ctrlMediaPartPlay(int dataType, MediaPartGather mediaPartGather);
    /**
     * 半屏播放
     * @since MediaCenter 1.0.0
     * @return true 执行成功, false 执行失败
     */
  public abstract boolean ctrlMediaPartPlay(int dataType, String uuid,String listId);
    /**
     * 半屏暂停
     * @since MediaCenter 1.0.0
     * @return true 执行成功, false 执行失败
     */
  public abstract boolean ctrlMediaPartPause(int dataType, String uuid,String listId);
  /**
     * 播放歌单（半屏）
     * @return true 执行成功, false 执行失败
     * @since MediaCenter 1.0.0
    */
  public abstract boolean ctrlPlayMediaListForMediaPart(int dataType,String mediaListId);

  /**
    * 暂停播放歌单（半屏）
    * @return true 执行成功, false 执行失败
  */
  public abstract boolean ctrlPauseMediaListForMediaPart(int dataType,String mediaListId);

```
ctrlMediaPartPlay(int dataType, MediaPartGather mediaPartGather);
用于半屏控制三方应用播放歌曲或歌单。

ctrlPlayMediaListForMediaPart(int dataType,String mediaListId);
用于半屏播放控制三方应用播放列表
dataType 对应
```java
MediaPartDataType.java
```
根据不同的类别，三方完成单曲或歌单的播放，同时通过现有接口将播放信息，播放列表，播放状状态等信息同步至媒体中心。

getMediaPartTabInfo(tabId)用于接受半屏刷新请求，三方接受到请求后使用
```java
MediaCenterAPI.get().getMediaPartClientAPI().updateMediaPartTabInfo(token,mediaPartTabInfoGatherNew);
```
将相应tab信息同步给媒体中心。

progressDrag(progress)用于接受半屏进度条拖动请求，完成媒体进度拖动后，调用
```java
MediaCenterAPI.get().getMediaPartClientAPI().updateCurrentProgress(token,  progress)
```
将先用进度同步给媒体中心。

接入半屏应用的三方在
```java
MediaCenterAPI.get().getMediaControllerApi().register('包名',musicClient)
```
方法获取token后，调用
```java
MediaCenterAPI.get().getMediaPartClientAPI().updateMediaPartTabInfo(token,mediaPartTabInfoGatherNew)
```
将半屏初始化信息同步到媒体中心。

MediaPartTabInfoGather半屏信息实体类实现参考如下:
```java
   public class MediaPartTabInfoGatherNew extends MediaPartTabInfoGather{
   @Override
   public List<MediaPartTabInfo> getMediaPartTabInfoList(){
        List <MediaPartTabInfo> mediaPartTabInfos = new ArrayList<>();
        mediaPartTabInfos.add(mediaPartTabInfoBanner);
        mediaPartTabInfos.add(mediaPartTabInfoMusic);
        mediaPartTabInfos.add(mediaPartTabInfoPodcasts);
        mediaPartTabInfos.add(mediaPartTabInfoVideo);
        mediaPartTabInfos.add(mediaPartTabInfoRadio);
        mediaPartTabInfos.add(mediaPartTabInfoNews);
        return mediaPartTabInfos;
     }
 };
```



MediaPartTabInfo 半屏Tab信息实现类实现参考如下：

```java
public class MediaPartTabInfoBanner extends  MediaPartTabInfo{
	@Override
	public int getTabId() {
			return 0;
	}
	@Override
	public String getTabTitle() {
			return "推荐";
	}
	@Override
	public List<MediaPartListInfo> getMediaPartList() {
			List<MediaPartListInfo> mediaPartListInfos = new ArrayList<>();
			mediaPartListInfos.add(mediaPartListInfoBanner);
			mediaPartListInfos.add(mediaPartListInfoGedan);
			return mediaPartListInfos;
	}
	@Override
	public PendingIntent getPendingIntent() {
			ComponentName cn = new ComponentName("com.zeekr.**", "com.zeekr.local.ui.main.*****");
			Intent intent = new Intent();
			intent.setComponent(cn);
			intent.setFlags(FLAG_ACTIVITY_NEW_TASK);
			PendingIntent pendingIntent = PendingIntent.getActivity(MediaCenterActivity.this, 999,
							intent,
							PendingIntent.FLAG_UPDATE_CURRENT);
			return  pendingIntent;
	}
}
```

MediaPartListInfo 半屏歌曲列表信息实现类实现参考如下 ：
```java
public class  MediaPartListInfoNew  extends MediaPartListInfo{
        @Override
        public String getMediaListTitle() {
            return "列表标题(单曲)";
        }
        @Override
        public String getMediaListId() {
            return "0";
        }
        @Override
        public Uri getArtwork() {
            return null;
        }
        @Override
        @SuppressLint({"WrongConstant"})
        public int getMediaPartDataType() {
            return MediaPartDataType.PART_TYPE_MUSIC;
        }
        @Override
        @SuppressLint({"WrongConstant"})
        public int getMediaPartDisplayType() {
            return MediaPartDisplayType.DISPLAY_TYPE_HOT_MUSIC;
        }
        @Override
        public List<MediaPartInfo> getMediaList() {
            List<MediaPartInfo> mediaPartInfos = new ArrayList<>();
            mediaPartInfos.add(mediaPartInfoNew);
            mediaPartInfos.add(mediaPartInfoNew);
            mediaPartInfos.add(mediaPartInfoNew);
            return mediaPartInfos;
        }
        @Override
        public PendingIntent getPendingIntent() {
            return null;
        }
    }
```
MediaPartDataType为当前列表数据类型对应文件(区分单曲列表，歌单列表，banner和功能模块列表)
```java
MediaPartDataType.java
```
PART_TYPE_MUSIC = 0; //单曲歌单

PART_TYPE_FUNC = 1;//功能模块

PART_TYPE_LIST = 2;//歌单中包含歌单

PART_TYPE_BANNER = 4;//banner

|       常量         | 数据类型 |
| -------------- | -------- |
| PART_TYPE_MUSIC     | 单曲歌单         |
| PART_TYPE_FUNC     | 功能模块         |
| PART_TYPE_LIST     | 歌单中包含歌单         |
| PART_TYPE_BANNER     | banner图         |

MediaPartDisplayType为当前列表显示类型对应文件（半屏跟据显示类型完成不同列表的页面数据展示）
```java
MediaPartDisplayType.java
```
DISPLAY_TYPE_BANNER = 0; //banner

DISPLAY_TYPE_FUNC = 1;//功能模块

DISPLAY_TYPE_LEADERBOARD = 2;//显示列表-排行榜(单张图片)

DISPLAY_TYPE_SINGLE_ROW =3;//显示列表-单排（标题+单行歌曲列表）

DISPLAY_TYPE_DOUBLE_ROW =4;//显示列表-双排（标题+双行歌曲列表）



|       常量         | 显示类型 |
| -------------- | -------- |
| DISPLAY_TYPE_BANNER     | banner         |
| DISPLAY_TYPE_FUNC     | 功能         |
| DISPLAY_TYPE_LEADERBOARD     | 显示列表-排行榜(单张图片)        |
| DISPLAY_TYPE_SINGLE_ROW     | 显示列表-单排（标题+单行歌曲列表） |
| DISPLAY_TYPE_DOUBLE_ROW     | 显示列表-双排（标题+双行歌曲列表） |

MediaPartInfo 半屏歌曲信息实现类实现参考如下 ：
```java
public class  MediaPartInfoNew extends MediaPartInfo{
    @Override
    public MediaPartGather getMediaPartGather() {
        return null;
    }
    @Override
    public MediaPartFuncGather getMediaPartFuncGather() {
        return null;
    }
    @Override
    public MediaPartBannerGather getMediaPartBannerGather() {
        return null;
    }
}
```
该实现类包括四钟数据类型 三方应用根据PartMediaType分别对相应的对象赋值：

PART_TYPE_MUSIC -->MediaPartGather

PART_TYPE_FUNC  -->MediaPartFuncGather

PART_TYPE_BANNER -->MediaPartBannerGather

PART_TYPE_LIST  -->MediaPartListGather



此方法用于三方应用全屏时 将当前所处页tabId同步至媒体中心。
```java
MediaCenterAPI.get().getMediaPartClientAPI().updateCurrentTab(token,tabId)
```


此方法将APP启动pendingIntent同步至媒体中心，建议于MediaCenterAPI.get().getMediaControllerApi().register('包名',musicClient)方法获取token后调用
```java
MediaCenterAPI.get().getMediaPartClientAPI().updateStartUp(token,pendingIntent);
```
控制暂停，上下首切换，歌曲信息同步等方法仍保持已有逻辑。
#### App控制

控制端控制能力依赖“媒体被控制端”的requestControlled，只有被控制端请求被控制成功后，控制端才能控制。

注册，获取App控制Token
```java
// App控制权变化的回调
private MediaController mMediaController = new MediaController() {
    @Override
    public void onControllerChanged(String controllerPackageName) {
    // 控制权变化时，会收到此回调（此时控制权已被controllerPakcageName对应的App抢占）
    }

    @Override
    public void updatePlaylist(int sourceType, List<Media> playlist) {
    // @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
    // 接收来自受控端多媒体播放列表更新的回调
    }

    @Override
    public void updatePlaybackInfo(MusicPlaybackInfo playbackInfo) {
    // @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
    // 接收来自受控端多媒体当前播放媒体信息更新的回调
    }

    @Override
    public void updateErrorMsg(int sourceType, String errorMsg) {
    // @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
    // 接收异常状态信息的回调，例如蓝牙断开，USB断开等等
    }

    @Override
    public void updateCurrentProgress(long progress) {
    // @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
    // 更新当前播放进度
    }
    @Override
    public void updateMediaContentTypeList(List<IMediaContentType> mediaContentTypeList) 2
    // @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 342
    // 接收来自受控端多媒体内容分类列表更新的回调
    }
};

// 获取控制端API实例
IMediaControllerAPI mControllerAPI = ZeekrMediaCenterAPI.get().getMediaControllerApi();
// 注册获取App控制Token（后续所有IMediaControllerAPI的接口需要传递此token）
Object mControllerToken = mControllerAPI.register(‘应用包名’, mMediaController) ;
```
PS：
Q：为什么new MediaController()了，但是却收不到回调。
A：目前的版本暂时不支持匿名内部类的方式调用，请使用类似上述成员变量的方式进行调用，后续版本可能会考虑兼容。

申请控制权

```java
// 申请控制权（只有申请成功后，才能控制媒体端）
boolean result = mControllerAPI.requestControl(mControllerToken) ;

获取媒体端支持的所有内容分类列表


// 获取媒体端支持的所有内容分类列表
mControllerAPI.getMediaContentTypeList(mControllerToken);
```

被控制端注册，三方应用（目前用于具体情景模式下的歌曲播放,休憩模式 影院模式等）（APP控制）

```java
	public class CustomMediaControlClient extends MediaControlClient {
		@Override
		public void onControlledChanged(String controlledPackageName) {
			//被控制权变化的回调，controllerPakcageName为当前获得到控制权媒体端的包名
		}

		@Override
		public List<IMediaContentType> getMediaContentTypeList() {
			//实现返回媒体内容分类列表
			return null;
		}

		@Override
		public boolean onPlay(int soundSourceType, String mediaContentTypeId) {
			//实现指定音源且指定媒体内容分类的播放
			return false; // 执行成功，则返回true
		}

		@Override
		public boolean onPlayByContent(int soundSourceType, String filterContent) {
			//实现指定音源且指定过滤内容关键字的播放
			return false;// 执行成功，则返回true
		}

		@Override
		public boolean onPause(int soundSourceType) {
			//  实现暂停播放指定音源
			return false; // 执行成功，则返回true
		}

		@Override
		public boolean onResumeNow() {
			//  实现恢复播放
			//  @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
			return false; // 执行成功，则返回true
		}

		@Override
		public boolean onPauseNow() {
			//  实现暂停播放
			//   @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
			return false; // 执行成功，则返回true
		}

		@Override
		public boolean onPlayByMediaId(int soundSourceType, String uuid) {
			//  实现指定音源指定媒体ID的播放
			//   @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
			return false; // 执行成功，则返回true
		}
	}

 IMediaControlClientAPI mControlClientAPI =                MediaCenterAPI.get().getMediaControlClientApi();
 MediaControlClient mMediaControlClient=new CustomMediaControlClient();
  // 注册获取被控制端Token（后续所有IMediaControlClientAPI的接口需要传递此token）
 Object mControlClientToken = mControlClientAPI.register(‘应用包名’,mMediaControlClient) ;
  // 申请被控制权（只有申请成功后，才能被其它App控制）
 boolean result = mControlClientAPI.requestControlled(mControlClientToken) ;
    //取消被控制
 mControlClientAPI.unregister(mControlClientToken) ;
```
控制端控制能力依赖“媒体被控制端”的requestControlled，只有被控制端请求被控制成功后，控制端才能控制（目前用于小憩模式）（APP端控制）
```java
	public class MediaControllerNew extends MediaController{

		@Override
		public void onControllerChanged(String controllerPakcageName) {
		 // 控制权变化时，会收到此回调（此时控制权已被controllerPakcageName对应的App抢占）
		}
	   @Override
		public void updatePlaylist(int sourceType, List<Media> playlist) {
		// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
		// 接收来自受控端多媒体播放列表更新的回调
		}

		@Override
		public void updatePlaybackInfo(MusicPlaybackInfo playbackInfo) {
		// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
		// 接收来自受控端多媒体当前播放媒体信息更新的回调
		}

		@Override
		public void updateErrorMsg(int sourceType, String errorMsg) {
		// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
		// 接收异常状态信息的回调，例如蓝牙断开，USB断开等等
		}

		@Override
		public void updateCurrentProgress(long progress) {
		// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
		// 更新当前播放进度
		}
		@Override
		public void updateMediaContentTypeList(List<IMediaContentType> mediaContentTypeList){
		// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 342
		// 接收来自受控端多媒体内容分类列表更新的回调
	 }

	}
iMediaCenterToken = MediaCenterAPI.get().getMediaControllerApi().register("三方app包名", MediaControllerNew);

//控制端请求控制
boolean b = MediaCenterAPI.get().getMediaControllerApi().requestControl(iMediaCenterToken);

//控制端暂停被控制端
boolean b = MediaCenterAPI.get().getMediaControllerApi().playCtrlPause(iMediaCenterToken);

//控制端暂停指定音源的播放
boolean b = MediaCenterAPI.get().getMediaControllerApi().playCtrlPause(iMediaCenterToken,  soundSourceType);

//控制端播放被控制端
boolean b = MediaCenterAPI.get().getMediaControllerApi().playCtrlPlay(iMediaCenterToken);

//控制端播放指定音源且包含指定内容的媒体
boolean b = MediaCenterAPI.get().getMediaControllerApi().playCtrlPlayByContent(iMediaCenterToken, soundSourceType,  filterContent);

//获取当前播放列表所在音源
int i = MediaCenterAPI.get().getMediaControllerApi().getSourceType(iMediaCenterToken);

//获取当前多媒体播放列表
MediaCenterAPI.get().getMediaControllerApi().getMediaList(iMediaCenterToken);

//获取当前播放媒体信息
MediaCenterAPI.get().getMediaControllerApi().getMusicPlaybackInfo(iMediaCenterToken);
```

```java
// 获取媒体端支持的所有内容分类列表
mControllerAPI.getMediaContentTypeList(mControllerToken);
```
目前支持的内容分类列表如下：

|       id         | title |
| -------------- | -------- |
|-1	 |内容分类|
|22	|风格|
|23	|流行|
|24|	古典|
|25|	爵士|
|26	|轻音乐|
|27	|嘻哈|
|28|	电子|
|29	|民谣|
|30	|摇滚|
|46	|语种|
|47|	国语|
|49	|英语|
|50	|韩语|
|52	|小语种|
|53	|西班牙语|
|54	|法语|
|56	|主题|
|57	|榜单|
|58	|儿歌|
|59	|经典|
|60	|网络|
|61	|游戏|
|62	|动漫|
|64|	怀旧|
|89	|情感|
|90	|暗恋|
|91	|思念|
|93	|励志|
|94	|快乐|
|95	|孤独|
|96	|甜蜜|
|98	|放松|
|99	|治愈|
|100|	安静|
|103|	浪漫|
|104|	场景|
|105|	咖啡馆
|106|	做公交|
|107|	打游戏|
|108|	SPA馆|
|109|	沐浴|
|110|	调情|
|111	|学习|
|112	|婚礼|
|113|酒吧&运动|

播放指定音源且指定内容分类的媒体

```java
// soundSourceType为音源类型
// mediaContentTypeId为媒体内容分类id（对应上面getMediaContentTypeList接口中分类的id）
// 如：
// 1. 播放蓝牙音乐时：soundSourceType传（SourceType.SOURCE_TYPE_BT），mediaContentTypeId传null；
// 2. 播放舒缓音乐时：soundSourceType传（即SourceType.SOURCE_TYPE_ONLINE），mediaContentTypeId传："98"（放松），"99"（治愈），"100"（安静），"103"（浪漫）中的任意一个
mControllerAPI.playCtlPlay(mControllerToken, soundSourceType, mediaContentTypeId);
```
控制端指定音源且指定特定媒体信息播放

```java
// soundSourceType 为音源枚举值，uuid为特定媒体的ID(音乐音源则为歌曲ID，电台音源则为电台节目ID，其他类似)
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
mControllerAPI.playCtrlPlayByMediaID(mControllerToken,soundSourceType, uuid);
```

控制端恢复当前媒体播放

```java
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
mControllerAPI.playCtrlPlay(mControllerToken);
```

控制端暂停当前媒体播放

```java
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
mControllerAPI.playCtrlPause(mControllerToken);
```
获取当前播放列表所在音源

```java
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
mControllerAPI.getSourceType(mControllerToken);
```

获取当前多媒体播放列表

```java
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
mControllerAPI.getMediaList(mControllerToken);
```

获取当前播放媒体信息

```java
// @since {@link com.ecarx.sdk.ECarXAPIBase#VERSION_INT} 341
mControllerAPI.getMusicPlaybackInfo(mControllerToken);
```
根据内容过滤播放指定音源
```java

// soundSourceType为音源类型，filterContent为内容过滤关键字
// 如：实现随便听听：soundSourceType传(即SourceType.SOURCE_TYPE_ONLINE)；filterContent传“recommend”
mControllerAPI.playCtrlPlayByContent(mControllerToken, soundSourceType, filterContent);
```

暂停播放指定音源

```java

// 控制端暂停指定音源的播放：soundSourceType传需要暂停的音源（如需要暂停在线音
//乐，则soundSourceType传(SourceType.SOURCE_TYPE_ONLINE)
mControllerAPI.playCtrlPause(mControllerToken,soundSourceType);
```
被控制能力声明

```java
// 获取媒体被控制端API实例
IMediaControlClientAPI mControlClientAPI = ZeekrMediaCenterAPI.get().getMediaControlClientApi();
MediaControlClient mMediaControlClient=new CustomMediaControlClient();
// 注册获取被控制端Token（后续所有IMediaControlClientAPI的接口需要传递此token）
Object mControlClientToken = mControlClientAPI.register(‘应用包名’,mMediaControlClient) ;

// 申请被控制权（只有申请成功后，才能被其它App控制）
boolean result = mControlClientAPI.requestControlled(mControlClientToken) ;
```





#### 蓝牙双音源

监听蓝牙变化方法

```java
// BtHeadset listner
private BtHeadsetListener mBtHeadsetListener = new BtHeadsetListener() {
     //BtHeadStatus:蓝牙连接状态 ：1：已连接 2:已断开
     //needClear:蓝牙连接状态变化后，是否需要保持原有歌曲状态。如果传入false，需要保持之前的播放状态（继续播放或保持暂停），重新requestPlay之后 updateMusicPlaybackState同步数据
    @Override
    public void onBtHeadsetConnectChanged(int BtHeadStatus,Boolean needclear) {

    }
};

```

```java
MediaCenterAPI.get().registerBtHeadset(token, mBtHeadsetListener);//注册蓝牙连接状态
```

```java
int MediaCenterAPI.get().getBtHeadsetStatus();//获取蓝牙连接状态，返回值 1：已连接，2：已断开
```



声音如何从蓝牙耳机输出

当前策略需要增加usage.以满足两路输出。需要集成Policy模块，获取蓝牙耳机usage

获取usage方法

```java
     PolicyAPI.get().getAudioAttributes().getAudioAttributesUsage(IAudioAttributes.USAGE_MD_BTHeadset_AUDIO);

```

使用获取到的usage申请焦点。



申请新的音频焦点成功后，如果需要注册媒体中心请使用以下方法：

```java
MediaCenterAPI.get().requestPlay(token,audioType);//audioType 0x0000:default Audio  0x0001:Bluetooth headset

audioType 取值
PlaybackState.class
/**
 * 蓝牙状态连接
 */
public static final int AUDIO_TYPE_CONNECTED = 1;


/**
 * 蓝牙状态连接
 */
public static final int AUDIO_TYPE_DISCONNECTED = 2;
```
